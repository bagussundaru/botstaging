//@version=5
strategy("Metode Sniper - Steven G. Tunas", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=2, initial_capital=10000, currency=currency.USD)

// =====================
// === METODE SNIPER PARAMETERS
// =====================

// 1. Trend Filter - Moving Averages
trend_period = input.int(20, "EMA Trend Period (Trend_Period)", minval=5, maxval=200, group="Trend Filter")
trend_period_slow = input.int(60, "EMA Slow Period", minval=20, maxval=200, group="Trend Filter")
trend_htf = input.timeframe("60", "Higher Timeframe (Trend_HTF)", group="Trend Filter")

// 2. RSI Oscillator
rsi_period = input.int(14, "RSI Period", minval=2, maxval=50, group="Momentum")
rsi_oversold = input.int(30, "RSI Oversold Level", minval=10, maxval=40, group="Momentum")
rsi_overbought = input.int(70, "RSI Overbought Level", minval=60, maxval=90, group="Momentum")

// 3. Support & Resistance Detection
pivot_left = input.int(5, "Pivot Left Bars", minval=1, maxval=20, group="Support & Resistance")
pivot_right = input.int(5, "Pivot Right Bars", minval=1, maxval=20, group="Support & Resistance")
sr_tolerance_pct = input.float(0.003, "S&R Zone Tolerance (%)", minval=0.0001, maxval=0.01, step=0.0001, group="Support & Resistance")
n_div_lookback = input.int(12, "Divergence Lookback Bars", minval=4, maxval=50, group="Support & Resistance")

// 4. Risk Management
atr_period = input.int(14, "ATR Period", minval=5, maxval=50, group="Risk Management")
atr_sl_multiplier = input.float(1.5, "ATR SL Multiplier (ATR_SL_Multiplier)", minval=0.5, maxval=3.0, step=0.1, group="Risk Management")
rr_target = input.float(2.0, "Risk Reward Target (RR_Target)", minval=1.0, maxval=5.0, step=0.1, group="Risk Management")
risk_per_trade = input.float(0.02, "Risk Per Trade (%)", minval=0.001, maxval=0.1, step=0.001, group="Risk Management")
min_sl_pips = input.float(5, "Minimum SL (pips)", minval=1, maxval=50, step=0.1, group="Risk Management")

// 5. Confidence Scoring Weights (Optimized based on performance analysis)
w_trend = input.float(2.0, "Weight - Trend Alignment", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_mtf = input.float(1.8, "Weight - MTF Alignment", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_sr = input.float(1.5, "Weight - S&R Zone", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_candle = input.float(1.2, "Weight - Price Action", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_rsi = input.float(1.0, "Weight - RSI Signal", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_div = input.float(1.5, "Weight - Divergence", minval=0, maxval=5, step=0.1, group="Confidence Weights")

// 6. Execution Settings (Optimized for better win rate)
min_confidence = input.float(0.45, "Minimum Confidence Level", minval=0.1, maxval=1.0, step=0.01, group="Execution")
cooldown_bars = input.int(5, "Cooldown Bars After Entry", minval=0, maxval=50, group="Execution")
use_risk_sizing = input.bool(true, "Use Risk-Based Position Sizing", group="Execution")
allow_long = input.bool(true, "Allow Long Trades", group="Execution")
allow_short = input.bool(true, "Allow Short Trades", group="Execution")

// 7. Display Settings
show_ema = input.bool(true, "Show EMA Lines", group="Display")
show_sr_zones = input.bool(true, "Show S&R Zones", group="Display")
show_signals = input.bool(true, "Show Entry Signals", group="Display")
show_debug = input.bool(false, "Show Debug Info", group="Display")

// =====================
// === CORE INDICATORS
// =====================

// Moving Averages
ema_fast = ta.ema(close, trend_period)
ema_slow = ta.ema(close, trend_period_slow)

// Higher Timeframe EMA
[close_htf, ema_htf] = request.security(syminfo.tickerid, trend_htf, [close, ta.ema(close, trend_period)])

// RSI
rsi = ta.rsi(close, rsi_period)
rsi_prev = ta.rsi(close[1], rsi_period)

// ATR for volatility
atr = ta.atr(atr_period)

// =====================
// === SUPPORT & RESISTANCE DETECTION
// =====================

// Pivot High/Low Detection
pivot_high = ta.pivothigh(high, pivot_left, pivot_right)
pivot_low = ta.pivotlow(low, pivot_left, pivot_right)

// Store recent S&R levels
var float[] resistance_levels = array.new_float()
var float[] support_levels = array.new_float()

// Update S&R levels when new pivots are found
if not na(pivot_high)
    if array.size(resistance_levels) >= 5
        array.shift(resistance_levels)
    array.push(resistance_levels, pivot_high)

if not na(pivot_low)
    if array.size(support_levels) >= 5
        array.shift(support_levels)
    array.push(support_levels, pivot_low)

// Find nearest S&R levels
get_nearest_resistance() =>
    float nearest = na
    if array.size(resistance_levels) > 0
        for i = 0 to array.size(resistance_levels) - 1
            level = array.get(resistance_levels, i)
            if level > close and (na(nearest) or level < nearest)
                nearest := level
    nearest

get_nearest_support() =>
    float nearest = na
    if array.size(support_levels) > 0
        for i = 0 to array.size(support_levels) - 1
            level = array.get(support_levels, i)
            if level < close and (na(nearest) or level > nearest)
                nearest := level
    nearest

nearest_resistance = get_nearest_resistance()
nearest_support = get_nearest_support()

// Check if price is at S&R zone
is_at_support = not na(nearest_support) and close <= (nearest_support * (1 + sr_tolerance_pct)) and close >= (nearest_support * (1 - sr_tolerance_pct))
is_at_resistance = not na(nearest_resistance) and close >= (nearest_resistance * (1 - sr_tolerance_pct)) and close <= (nearest_resistance * (1 + sr_tolerance_pct))

// =====================
// === PRICE ACTION PATTERNS
// =====================

// Candlestick body and wick calculations
body_size = math.abs(close - open)
upper_wick = high - math.max(close, open)
lower_wick = math.min(close, open) - low
total_range = high - low

// Doji Pattern
is_doji = body_size <= (total_range * 0.1) and total_range > 0

// Pin Bar (Hammer/Shooting Star)
is_hammer = (close > open) and (lower_wick >= body_size * 2) and (upper_wick <= body_size * 0.5)
is_shooting_star = (close < open) and (upper_wick >= body_size * 2) and (lower_wick <= body_size * 0.5)

// Inside Bar
is_inside_bar = (high < high[1]) and (low > low[1])

// Engulfing Patterns
is_bullish_engulfing = (close > open) and (close[1] < open[1]) and (close > open[1]) and (open < close[1])
is_bearish_engulfing = (close < open) and (close[1] > open[1]) and (close < open[1]) and (open > close[1])

// Price Action Confirmations
bullish_price_action = is_hammer or is_bullish_engulfing or (is_doji and is_at_support)
bearish_price_action = is_shooting_star or is_bearish_engulfing or (is_doji and is_at_resistance)

// =====================
// === DIVERGENCE DETECTION
// =====================

// Simple divergence detection using lookback method
bullish_divergence = (low < ta.lowest(low, n_div_lookback)) and (rsi > ta.lowest(rsi, n_div_lookback))
bearish_divergence = (high > ta.highest(high, n_div_lookback)) and (rsi < ta.highest(rsi, n_div_lookback))

// =====================
// === TREND ANALYSIS
// =====================

// Local trend (current timeframe)
is_uptrend = close > ema_fast and ema_fast > ema_slow
is_downtrend = close < ema_fast and ema_fast < ema_slow

// Higher timeframe trend alignment
htf_uptrend = close_htf > ema_htf
htf_downtrend = close_htf < ema_htf

// Trend alignment
trend_aligned_bull = is_uptrend and htf_uptrend
trend_aligned_bear = is_downtrend and htf_downtrend

// =====================
// === RSI MOMENTUM SIGNALS
// =====================

// Enhanced Risk Management with trailing stop
use_trailing_stop = input.bool(true, "Use Trailing Stop", group="Risk Management")
trailing_stop_pct = input.float(0.5, "Trailing Stop (%)", minval=0.1, maxval=2.0, step=0.1, group="Risk Management")

// Enhanced RSI Momentum Signals (More selective)
rsi_bullish = (rsi < rsi_oversold and rsi > rsi_prev + 2) or (rsi < 35 and rsi > rsi_prev + 3 and close > ema_fast)
rsi_bearish = (rsi > rsi_overbought and rsi < rsi_prev - 2) or (rsi > 65 and rsi < rsi_prev - 3 and close < ema_fast)

// Additional confirmation filters
volume_confirmation = volume > ta.sma(volume, 20) * 1.2
atr_filter = atr > ta.sma(atr, 14) * 0.8  // Avoid low volatility periods

// =====================
// === CONFIDENCE SCORING SYSTEM
// =====================

// Calculate confidence scores
bull_score = 0.0
bear_score = 0.0

// Trend component
if trend_aligned_bull
    bull_score += w_trend
if htf_uptrend and is_uptrend
    bull_score += w_mtf

if trend_aligned_bear
    bear_score += w_trend
if htf_downtrend and is_downtrend
    bear_score += w_mtf

// S&R component
if is_at_support
    bull_score += w_sr
if is_at_resistance
    bear_score += w_sr

// Price Action component
if bullish_price_action
    bull_score += w_candle
if bearish_price_action
    bear_score += w_candle

// RSI component
if rsi_bullish
    bull_score += w_rsi
if rsi_bearish
    bear_score += w_rsi

// Divergence component
if bullish_divergence
    bull_score += w_div
if bearish_divergence
    bear_score += w_div

// Normalize confidence scores
max_possible_score = w_trend + w_mtf + w_sr + w_candle + w_rsi + w_div
confidence_bull = bull_score / max_possible_score
confidence_bear = bear_score / max_possible_score

// =====================
// === ENTRY LOGIC & RISK MANAGEMENT
// =====================

// Track last entry bars for cooldown
var int last_long_bar = na
var int last_short_bar = na

// Calculate Stop Loss and Take Profit levels
calc_sl_tp_long() =>
    // Use multiple SL methods and take the most conservative
    atr_sl = close - (atr * atr_sl_multiplier)
    sr_sl = na(nearest_support) ? atr_sl : nearest_support - (atr * 0.2)
    swing_sl = ta.lowest(low, 10) - (atr * 0.1)
    
    sl_price = math.max(atr_sl, math.max(sr_sl, swing_sl))
    sl_distance = close - sl_price
    
    // Dynamic TP based on market conditions
    base_tp = close + (sl_distance * rr_target)
    resistance_tp = na(nearest_resistance) ? base_tp : math.min(base_tp, nearest_resistance - (atr * 0.1))
    tp_price = resistance_tp
    
    [sl_price, tp_price, sl_distance]

calc_sl_tp_short() =>
    // Use multiple SL methods and take the most conservative
    atr_sl = close + (atr * atr_sl_multiplier)
    sr_sl = na(nearest_resistance) ? atr_sl : nearest_resistance + (atr * 0.2)
    swing_sl = ta.highest(high, 10) + (atr * 0.1)
    
    sl_price = math.min(atr_sl, math.min(sr_sl, swing_sl))
    sl_distance = sl_price - close
    
    // Dynamic TP based on market conditions
    base_tp = close - (sl_distance * rr_target)
    support_tp = na(nearest_support) ? base_tp : math.max(base_tp, nearest_support + (atr * 0.1))
    tp_price = support_tp
    
    [sl_price, tp_price, sl_distance]

// Entry conditions
can_enter_long = allow_long and confidence_bull >= min_confidence and 
                 volume_confirmation and atr_filter and
                 (na(last_long_bar) or (bar_index - last_long_bar) > cooldown_bars) and
                 not (rsi > 75)  // Avoid overbought entries

can_enter_short = allow_short and confidence_bear >= min_confidence and 
                  volume_confirmation and atr_filter and
                  (na(last_short_bar) or (bar_index - last_short_bar) > cooldown_bars) and
                  not (rsi < 25)  // Avoid oversold entries

// Create alert messages for strategy orders
long_alert_msg = '{"action": "BUY", "symbol": "' + syminfo.ticker + '", "exchange": "' + syminfo.prefix + '", "price": ' + str.tostring(close) + ', "confidence": ' + str.tostring(confidence_bull, "#.##") + ', "timestamp": ' + str.tostring(time) + ', "strategy": "Sniper Method", "timeframe": "' + timeframe.period + '", "token": "AUTH_TOKEN_PLACEHOLDER"}'

short_alert_msg = '{"action": "SELL", "symbol": "' + syminfo.ticker + '", "exchange": "' + syminfo.prefix + '", "price": ' + str.tostring(close) + ', "confidence": ' + str.tostring(confidence_bear, "#.##") + ', "timestamp": ' + str.tostring(time) + ', "strategy": "Sniper Method", "timeframe": "' + timeframe.period + '", "token": "AUTH_TOKEN_PLACEHOLDER"}'

// Execute trades with enhanced exit strategy
if can_enter_long
    [sl_long, tp_long, sl_dist_long] = calc_sl_tp_long()
    if sl_dist_long >= (min_sl_pips * syminfo.mintick)
        if use_risk_sizing
            qty_percent = math.min(95.0, (risk_per_trade * 100.0) * (close / sl_dist_long))
            strategy.entry("Long", strategy.long, qty=qty_percent, comment="Sniper Long: " + str.tostring(confidence_bull, "#.##"), alert_message=long_alert_msg)
        else
            strategy.entry("Long", strategy.long, comment="Sniper Long: " + str.tostring(confidence_bull, "#.##"), alert_message=long_alert_msg)
        
        // Enhanced exit strategy
        if use_trailing_stop
            trail_points = math.round((close * trailing_stop_pct / 100) / syminfo.mintick)
            strategy.exit("Exit Long", "Long", stop=sl_long, limit=tp_long, trail_points=trail_points, trail_offset=trail_points)
        else
            strategy.exit("Exit Long", "Long", stop=sl_long, limit=tp_long)
        last_long_bar := bar_index

if can_enter_short
    [sl_short, tp_short, sl_dist_short] = calc_sl_tp_short()
    if sl_dist_short >= (min_sl_pips * syminfo.mintick)
        if use_risk_sizing
            qty_percent = math.min(95.0, (risk_per_trade * 100.0) * (close / sl_dist_short))
            strategy.entry("Short", strategy.short, qty=qty_percent, comment="Sniper Short: " + str.tostring(confidence_bear, "#.##"), alert_message=short_alert_msg)
        else
            strategy.entry("Short", strategy.short, comment="Sniper Short: " + str.tostring(confidence_bear, "#.##"), alert_message=short_alert_msg)
        
        // Enhanced exit strategy
        if use_trailing_stop
            trail_points = math.round((close * trailing_stop_pct / 100) / syminfo.mintick)
            strategy.exit("Exit Short", "Short", stop=sl_short, limit=tp_short, trail_points=trail_points, trail_offset=trail_points)
        else
            strategy.exit("Exit Short", "Short", stop=sl_short, limit=tp_short)
        last_short_bar := bar_index

// Partial profit taking for better risk management
var float long_entry_price = na
var float short_entry_price = na

if strategy.position_size > 0 and na(long_entry_price)
    long_entry_price := strategy.position_avg_price

if strategy.position_size < 0 and na(short_entry_price)
    short_entry_price := strategy.position_avg_price

// Take partial profits at 1:1 RR
if strategy.position_size > 0 and not na(long_entry_price)
    profit_target_1 = long_entry_price + (long_entry_price - strategy.position_avg_price) * 1.0
    if close >= profit_target_1
        strategy.close("Long", qty_percent=30, comment="Partial TP Long 1:1")

if strategy.position_size < 0 and not na(short_entry_price)
    profit_target_1 = short_entry_price - (strategy.position_avg_price - short_entry_price) * 1.0
    if close <= profit_target_1
        strategy.close("Short", qty_percent=30, comment="Partial TP Short 1:1")

// Reset entry prices when position is closed
if strategy.position_size == 0
    long_entry_price := na
    short_entry_price := na

// =====================
// === PLOTTING & VISUALIZATION
// =====================

// Plot EMAs
plot(show_ema ? ema_fast : na, "EMA Fast", color=color.blue, linewidth=2)
plot(show_ema ? ema_slow : na, "EMA Slow", color=color.red, linewidth=2)
plot(show_ema ? ema_htf : na, "EMA HTF", color=color.purple, linewidth=2, style=plot.style_circles)

// Plot S&R zones
if show_sr_zones and not na(nearest_support)
    support_top = nearest_support * (1 + sr_tolerance_pct)
    support_bottom = nearest_support * (1 - sr_tolerance_pct)
    box.new(bar_index - 1, support_top, bar_index, support_bottom, border_color=color.new(color.green, 70), bgcolor=color.new(color.green, 90))

if show_sr_zones and not na(nearest_resistance)
    resistance_top = nearest_resistance * (1 + sr_tolerance_pct)
    resistance_bottom = nearest_resistance * (1 - sr_tolerance_pct)
    box.new(bar_index - 1, resistance_top, bar_index, resistance_bottom, border_color=color.new(color.red, 70), bgcolor=color.new(color.red, 90))

// Plot entry signals
plotshape(show_signals and can_enter_long ? low : na, "Long Signal", 
          shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(show_signals and can_enter_short ? high : na, "Short Signal", 
          shape.triangledown, location.abovebar, color.red, size=size.small)

// Plot price action patterns
plotchar(bullish_price_action, "Bullish PA", "▲", location.belowbar, color.lime, size=size.tiny)
plotchar(bearish_price_action, "Bearish PA", "▼", location.abovebar, color.orange, size=size.tiny)

// Debug information with enhanced performance metrics
if show_debug and barstate.islast
    // Calculate recent performance metrics
    total_trades = strategy.closedtrades
    winning_trades = 0
    total_pnl = 0.0
    
    if total_trades > 0
        for i = 0 to math.min(total_trades - 1, 99)  // Last 100 trades
            trade_pnl = strategy.closedtrades.profit(i)
            total_pnl += trade_pnl
            if trade_pnl > 0
                winning_trades += 1
    
    win_rate = total_trades > 0 ? (winning_trades / math.min(total_trades, 100)) * 100 : 0
    avg_pnl = total_trades > 0 ? total_pnl / math.min(total_trades, 100) : 0
    
    debug_text = "=== SNIPER PERFORMANCE DEBUG ===\n" +
                 "Recent Win Rate: " + str.tostring(win_rate, "#.#") + "%\n" +
                 "Avg PnL (last 100): $" + str.tostring(avg_pnl, "#.##") + "\n" +
                 "Total Trades: " + str.tostring(total_trades) + "\n" +
                 "Bull Conf: " + str.tostring(confidence_bull, "#.###") + " (Min: " + str.tostring(min_confidence, "#.##") + ")\n" +
                 "Bear Conf: " + str.tostring(confidence_bear, "#.###") + " (Min: " + str.tostring(min_confidence, "#.##") + ")\n" +
                 "RSI: " + str.tostring(rsi, "#.#") + " (Prev: " + str.tostring(rsi_prev, "#.#") + ")\n" +
                 "Volume Conf: " + str.tostring(volume_confirmation) + " | ATR Filter: " + str.tostring(atr_filter) + "\n" +
                 "Trend: " + (is_uptrend ? "UP" : is_downtrend ? "DOWN" : "SIDE") + "\n" +
                 "HTF Trend: " + (htf_uptrend ? "UP" : htf_downtrend ? "DOWN" : "SIDE") + "\n" +
                 "At Support: " + str.tostring(is_at_support) + " | At Resistance: " + str.tostring(is_at_resistance) + "\n" +
                 "Can Enter Long: " + str.tostring(can_enter_long) + " | Short: " + str.tostring(can_enter_short)
    
    label.new(bar_index, high, debug_text,
              style=label.style_label_left, color=color.new(color.gray, 20), textcolor=color.white, size=size.small)

// Performance-based dynamic adjustments
var float dynamic_min_confidence = min_confidence
var int performance_check_bars = 0

// Check performance every 100 bars and adjust if needed
if barstate.islast and performance_check_bars % 100 == 0
    recent_trades = math.min(strategy.closedtrades, 20)  // Last 20 trades
    if recent_trades >= 10
        recent_wins = 0
        for i = 0 to recent_trades - 1
            if strategy.closedtrades.profit(i) > 0
                recent_wins += 1
        
        recent_win_rate = (recent_wins / recent_trades) * 100
        
        // Adjust confidence threshold based on performance
        if recent_win_rate < 40  // If win rate is too low
            dynamic_min_confidence := math.min(dynamic_min_confidence + 0.05, 0.8)
        else if recent_win_rate > 60  // If win rate is good, can be more aggressive
            dynamic_min_confidence := math.max(dynamic_min_confidence - 0.02, 0.25)

performance_check_bars += 1

// Use dynamic confidence in entry conditions
can_enter_long_dynamic = allow_long and confidence_bull >= dynamic_min_confidence and volume_confirmation and atr_filter and (na(last_long_bar) or (bar_index - last_long_bar) > cooldown_bars) and not (rsi > 75)

can_enter_short_dynamic = allow_short and confidence_bear >= dynamic_min_confidence and volume_confirmation and atr_filter and (na(last_short_bar) or (bar_index - last_short_bar) > cooldown_bars) and not (rsi < 25)

// Add alert condition indicators
bgcolor(can_enter_long ? color.new(color.green, 95) : can_enter_short ? color.new(color.red, 95) : na, title="Alert Condition Background")

// Add confidence score plots for better visibility
plot(confidence_bull, "Long Score", color=color.new(color.green, 50), display=display.data_window)
plot(confidence_bear, "Short Score", color=color.new(color.red, 50), display=display.data_window)
plot(min_confidence, "Min Threshold", color=color.new(color.yellow, 30), display=display.data_window)

// Plot individual scoring components for debugging
plot(show_debug ? bull_score : na, "Bull Raw Score", color=color.lime, display=display.data_window)
plot(show_debug ? bear_score : na, "Bear Raw Score", color=color.orange, display=display.data_window)
plot(show_debug ? max_possible_score : na, "Max Possible", color=color.white, display=display.data_window)

// =====================
// === WEBHOOK CONFIGURATION
// =====================

// Webhook settings
webhook_enabled = input.bool(true, "Enable Webhook Alerts", group="Webhook")
webhook_url = input.string("", "Webhook URL", group="Webhook")
auth_token = input.string("", "Authentication Token", group="Webhook")

// Create webhook payload for long entry
long_payload = '{"action": "BUY", "symbol": "' + syminfo.ticker + '", "exchange": "' + syminfo.prefix + '", "price": ' + str.tostring(close) + ', "confidence": ' + str.tostring(confidence_bull, "#.##") + ', "timestamp": ' + str.tostring(time) + ', "strategy": "Sniper Method", "timeframe": "' + timeframe.period + '", "token": "AUTH_TOKEN_PLACEHOLDER"}'

// Create webhook payload for short entry
short_payload = '{"action": "SELL", "symbol": "' + syminfo.ticker + '", "exchange": "' + syminfo.prefix + '", "price": ' + str.tostring(close) + ', "confidence": ' + str.tostring(confidence_bear, "#.##") + ', "timestamp": ' + str.tostring(time) + ', "strategy": "Sniper Method", "timeframe": "' + timeframe.period + '", "token": "AUTH_TOKEN_PLACEHOLDER"}'

// =====================
// === ALERTS
// =====================

// Traditional alerts
alertcondition(can_enter_long, "Sniper Long Signal", "Metode Sniper: Long Entry Signal - Confidence: {{plot_0}}")
alertcondition(can_enter_short, "Sniper Short Signal", "Metode Sniper: Short Entry Signal - Confidence: {{plot_0}}")

// Additional simplified alert conditions for testing
simple_long = confidence_bull >= 0.25 and rsi_bullish and is_uptrend
simple_short = confidence_bear >= 0.25 and rsi_bearish and is_downtrend

alertcondition(simple_long, "Simple Long Alert", "Simple Long: RSI Bullish + Uptrend - Confidence: {{plot_0}}")
alertcondition(simple_short, "Simple Short Alert", "Simple Short: RSI Bearish + Downtrend - Confidence: {{plot_1}}")

// Very basic alerts for testing
basic_rsi_long = rsi < 35 and rsi > rsi_prev and close > ema_fast
basic_rsi_short = rsi > 65 and rsi < rsi_prev and close < ema_fast

alertcondition(basic_rsi_long, "Basic RSI Long", "Basic RSI Long Signal")
alertcondition(basic_rsi_short, "Basic RSI Short", "Basic RSI Short Signal")

// Webhook alerts with JSON payload template
alertcondition(webhook_enabled and can_enter_long, "Webhook Long", '{"action": "BUY", "symbol": "{{ticker}}", "exchange": "{{exchange}}", "price": {{close}}, "confidence": "{{plot_0}}", "timestamp": {{time}}, "strategy": "Sniper Method", "timeframe": "{{interval}}", "token": "AUTH_TOKEN_PLACEHOLDER"}')
alertcondition(webhook_enabled and can_enter_short, "Webhook Short", '{"action": "SELL", "symbol": "{{ticker}}", "exchange": "{{exchange}}", "price": {{close}}, "confidence": "{{plot_1}}", "timestamp": {{time}}, "strategy": "Sniper Method", "timeframe": "{{interval}}", "token": "AUTH_TOKEN_PLACEHOLDER"}')

// =====================
// === END OF METODE SNIPER STRATEGY
// =====================