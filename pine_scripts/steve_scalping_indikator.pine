//@version=5
indicator("ðŸŽ¯ Sniper Method - Perfect Signal Match", overlay=true)

// =====================
// === METODE SNIPER PARAMETERS (EXACT MATCH)
// =====================

// 1. Trend Filter - Moving Averages
trend_period = input.int(20, "EMA Trend Period", minval=5, maxval=200, group="Trend Filter")
trend_period_slow = input.int(60, "EMA Slow Period", minval=20, maxval=200, group="Trend Filter")
trend_htf = input.timeframe("60", "Higher Timeframe", group="Trend Filter")

// 2. RSI Oscillator
rsi_period = input.int(14, "RSI Period", minval=2, maxval=50, group="Momentum")
rsi_oversold = input.int(30, "RSI Oversold Level", minval=10, maxval=40, group="Momentum")
rsi_overbought = input.int(70, "RSI Overbought Level", minval=60, maxval=90, group="Momentum")

// 3. Support & Resistance Detection
pivot_left = input.int(5, "Pivot Left Bars", minval=1, maxval=20, group="Support & Resistance")
pivot_right = input.int(5, "Pivot Right Bars", minval=1, maxval=20, group="Support & Resistance")
sr_tolerance_pct = input.float(0.003, "S&R Zone Tolerance (%)", minval=0.0001, maxval=0.01, step=0.0001, group="Support & Resistance")
n_div_lookback = input.int(12, "Divergence Lookback Bars", minval=4, maxval=50, group="Support & Resistance")

// 4. Risk Management
atr_period = input.int(14, "ATR Period", minval=5, maxval=50, group="Risk Management")
atr_sl_multiplier = input.float(1.5, "ATR SL Multiplier", minval=0.5, maxval=3.0, step=0.1, group="Risk Management")
rr_target = input.float(2.0, "Risk Reward Target", minval=1.0, maxval=5.0, step=0.1, group="Risk Management")
min_sl_pips = input.float(10, "Minimum SL (pips)", minval=5, maxval=50, step=0.1, group="Risk Management")

// 5. Confidence Scoring Weights (EXACT MATCH)
w_trend = input.float(2.0, "Weight - Trend Alignment", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_mtf = input.float(1.8, "Weight - MTF Alignment", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_sr = input.float(1.5, "Weight - S&R Zone", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_candle = input.float(1.2, "Weight - Price Action", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_rsi = input.float(1.0, "Weight - RSI Signal", minval=0, maxval=5, step=0.1, group="Confidence Weights")
w_div = input.float(1.5, "Weight - Divergence", minval=0, maxval=5, step=0.1, group="Confidence Weights")

// SOLUSDT specific weights (EXACT MATCH)
w_sol_trend = input.float(2.2, "SOL Weight - Trend", minval=0, maxval=5, step=0.1, group="SOL Specific")
w_sol_mtf = input.float(2.0, "SOL Weight - MTF", minval=0, maxval=5, step=0.1, group="SOL Specific")
w_sol_sr = input.float(1.8, "SOL Weight - S&R", minval=0, maxval=5, step=0.1, group="SOL Specific")
w_sol_candle = input.float(1.5, "SOL Weight - Candle", minval=0, maxval=5, step=0.1, group="SOL Specific")
w_sol_rsi = input.float(1.3, "SOL Weight - RSI", minval=0, maxval=5, step=0.1, group="SOL Specific")
w_sol_div = input.float(1.8, "SOL Weight - Divergence", minval=0, maxval=5, step=0.1, group="SOL Specific")

// 6. Execution Settings (EXACT MATCH)
min_confidence = input.float(0.25, "Minimum Confidence Level", minval=0.1, maxval=1.0, step=0.01, group="Execution")  // Dari 0.35 â†’ 0.25
cooldown_bars = input.int(5, "Cooldown Bars After Signal", minval=0, maxval=50, group="Execution")
allow_long = input.bool(true, "Allow Long Signals", group="Execution")
allow_short = input.bool(true, "Allow Short Signals", group="Execution")
// Tambahan: toggle untuk memakai confidence dinamis pada alert
use_dynamic_confidence = input.bool(false, "Use Dynamic Confidence For Alerts", group="Execution")  // True â†’ False

// 7. Display Settings
show_ema = input.bool(true, "Show EMA Lines", group="Display")
show_sr_zones = input.bool(true, "Show S&R Zones", group="Display")
show_signals = input.bool(true, "Show Entry Signals", group="Display")
show_debug = input.bool(false, "Show Debug Info", group="Display")

// =====================
// === CORE INDICATORS (EXACT MATCH)
// =====================

ema_fast = ta.ema(close, trend_period)
ema_slow = ta.ema(close, trend_period_slow)
[close_htf, ema_htf] = request.security(syminfo.tickerid, trend_htf, [close, ta.ema(close, trend_period)])

rsi = ta.rsi(close, rsi_period)
rsi_prev = ta.rsi(close[1], rsi_period)
atr = ta.atr(atr_period)

// =====================
// === SUPPORT & RESISTANCE (EXACT MATCH)
// =====================

pivot_high = ta.pivothigh(high, pivot_left, pivot_right)
pivot_low = ta.pivotlow(low, pivot_left, pivot_right)

var float[] resistance_levels = array.new_float()
var float[] support_levels = array.new_float()

if not na(pivot_high)
    if array.size(resistance_levels) >= 5
        array.shift(resistance_levels)
    array.push(resistance_levels, pivot_high)

if not na(pivot_low)
    if array.size(support_levels) >= 5
        array.shift(support_levels)
    array.push(support_levels, pivot_low)

get_nearest_resistance() =>
    float nearest = na
    if array.size(resistance_levels) > 0
        for i = 0 to array.size(resistance_levels) - 1
            level = array.get(resistance_levels, i)
            if level > close and (na(nearest) or level < nearest)
                nearest := level
    nearest

get_nearest_support() =>
    float nearest = na
    if array.size(support_levels) > 0
        for i = 0 to array.size(support_levels) - 1
            level = array.get(support_levels, i)
            if level < close and (na(nearest) or level > nearest)
                nearest := level
    nearest

nearest_resistance = get_nearest_resistance()
nearest_support = get_nearest_support()

is_at_support = not na(nearest_support) and close <= (nearest_support * (1 + sr_tolerance_pct)) and close >= (nearest_support * (1 - sr_tolerance_pct))
is_at_resistance = not na(nearest_resistance) and close >= (nearest_resistance * (1 - sr_tolerance_pct)) and close <= (nearest_resistance * (1 + sr_tolerance_pct))

// =====================
// === PRICE ACTION (EXACT MATCH)
// =====================

body_size = math.abs(close - open)
upper_wick = high - math.max(close, open)
lower_wick = math.min(close, open) - low
total_range = high - low

is_doji = body_size <= (total_range * 0.1) and total_range > 0
is_hammer = (close > open) and (lower_wick >= body_size * 2) and (upper_wick <= body_size * 0.5)
is_shooting_star = (close < open) and (upper_wick >= body_size * 2) and (lower_wick <= body_size * 0.5)
is_bullish_engulfing = (close > open) and (close[1] < open[1]) and (close > open[1]) and (open < close[1])
is_bearish_engulfing = (close < open) and (close[1] > open[1]) and (close < open[1]) and (open > close[1])

bullish_price_action = is_hammer or is_bullish_engulfing or (is_doji and is_at_support)
bearish_price_action = is_shooting_star or is_bearish_engulfing or (is_doji and is_at_resistance)

// =====================
// === DIVERGENCE (EXACT MATCH)
// =====================

bullish_divergence = (low < ta.lowest(low, n_div_lookback)) and (rsi > ta.lowest(rsi, n_div_lookback))
bearish_divergence = (high > ta.highest(high, n_div_lookback)) and (rsi < ta.highest(rsi, n_div_lookback))

// =====================
// === TREND ANALYSIS (EXACT MATCH)
// =====================

is_uptrend = close > ema_fast and ema_fast > ema_slow
is_downtrend = close < ema_fast and ema_fast < ema_slow
htf_uptrend = close_htf > ema_htf
htf_downtrend = close_htf < ema_htf

trend_aligned_bull = is_uptrend and htf_uptrend
trend_aligned_bear = is_downtrend and htf_downtrend

// =====================
// === ADVANCED INDICATORS (EXACT MATCH)
// =====================

stoch_k = ta.stoch(close, high, low, 14)
stoch_d = ta.sma(stoch_k, 3)
[macd_line, signal_line, macd_histogram] = ta.macd(close, 12, 26, 9)
williams_r = ta.wpr(14)

vwap = ta.vwap(hlc3)
volume_sma = ta.sma(volume, 20)
volume_ratio = volume / volume_sma
is_high_volume = volume_ratio > 1.5

swing_high = ta.highest(high, 20)
swing_low = ta.lowest(low, 20)
fib_618 = swing_low + (swing_high - swing_low) * 0.618
fib_382 = swing_low + (swing_high - swing_low) * 0.382
fib_236 = swing_low + (swing_high - swing_low) * 0.236

at_fib_618 = math.abs(close - fib_618) / close < 0.005
at_fib_382 = math.abs(close - fib_382) / close < 0.005

rsi_higher_low = rsi > rsi[1] and low < low[1]
rsi_lower_high = rsi < rsi[1] and high > high[1]
macd_bull_div = macd_line > macd_line[1] and low < low[1]
macd_bear_div = macd_line < macd_line[1] and high > high[1]

enhanced_bull_div = (rsi_higher_low or macd_bull_div) and bullish_divergence
enhanced_bear_div = (rsi_lower_high or macd_bear_div) and bearish_divergence

// =====================
// === RSI MOMENTUM (EXACT MATCH)
// =====================

rsi_bullish = (rsi < rsi_oversold and rsi > rsi_prev + 2) or (rsi < 35 and rsi > rsi_prev + 3 and close > ema_fast)
rsi_bearish = (rsi > rsi_overbought and rsi < rsi_prev - 2) or (rsi > 65 and rsi < rsi_prev - 3 and close < ema_fast)

volume_confirmation = volume > ta.sma(volume, 20) * 0.8
atr_filter = atr > ta.sma(atr, 14) * 0.3

// =====================
// === CONFIDENCE SCORING (EXACT MATCH)
// =====================

trend_score_bull = 0.0
trend_score_bear = 0.0

if trend_aligned_bull
    trend_score_bull += 0.4
if htf_uptrend
    trend_score_bull += 0.3
if close > vwap
    trend_score_bull += 0.3

if trend_aligned_bear
    trend_score_bear += 0.4
if htf_downtrend
    trend_score_bear += 0.3
if close < vwap
    trend_score_bear += 0.3

momentum_score_bull = 0.0
momentum_score_bear = 0.0

if rsi_bullish or (rsi < 40 and rsi > rsi[1])
    momentum_score_bull += 0.25
if rsi_bearish or (rsi > 60 and rsi < rsi[1])
    momentum_score_bear += 0.25

if stoch_k < 20 and stoch_k > stoch_d
    momentum_score_bull += 0.25
if stoch_k > 80 and stoch_k < stoch_d
    momentum_score_bear += 0.25

if macd_line > signal_line and macd_histogram > macd_histogram[1]
    momentum_score_bull += 0.25
if macd_line < signal_line and macd_histogram < macd_histogram[1]
    momentum_score_bear += 0.25

if williams_r < -80 and williams_r > williams_r[1]
    momentum_score_bull += 0.25
if williams_r > -20 and williams_r < williams_r[1]
    momentum_score_bear += 0.25

structure_score_bull = 0.0
structure_score_bear = 0.0

if is_at_support or at_fib_618 or at_fib_382
    structure_score_bull += 0.5
if bullish_price_action
    structure_score_bull += 0.5

if is_at_resistance or at_fib_618 or at_fib_382
    structure_score_bear += 0.5
if bearish_price_action
    structure_score_bear += 0.5

volume_score_bull = 0.0
volume_score_bear = 0.0

if is_high_volume and close > open
    volume_score_bull += 0.6
if close > vwap and volume_ratio > 1.2
    volume_score_bull += 0.4

if is_high_volume and close < open
    volume_score_bear += 0.6
if close < vwap and volume_ratio > 1.2
    volume_score_bear += 0.4

divergence_score_bull = enhanced_bull_div ? 1.0 : 0.0
divergence_score_bear = enhanced_bear_div ? 1.0 : 0.0

// Apply symbol-specific weights (EXACT MATCH)
is_sol_symbol = str.contains(syminfo.ticker, "SOL")
is_eth_symbol = str.contains(syminfo.ticker, "ETH")

// Use SOL-specific weights if SOL symbol
final_w_trend = is_sol_symbol ? w_sol_trend : w_trend
final_w_mtf = is_sol_symbol ? w_sol_mtf : w_mtf
final_w_sr = is_sol_symbol ? w_sol_sr : w_sr
final_w_candle = is_sol_symbol ? w_sol_candle : w_candle
final_w_rsi = is_sol_symbol ? w_sol_rsi : w_rsi
final_w_div = is_sol_symbol ? w_sol_div : w_div

// Calculate total weight for normalization
total_weight = final_w_trend + final_w_mtf + final_w_sr + final_w_candle + final_w_rsi + final_w_div

// Normalize weights to sum to 1.0
w_trend_final = final_w_trend / total_weight
w_momentum_final = final_w_rsi / total_weight  
w_structure_final = (final_w_sr + final_w_candle) / total_weight
w_volume_final = 0.15  // Keep volume at 15%
w_divergence_final = final_w_div / total_weight

// Adjust other weights to accommodate volume
adjustment_factor = (1.0 - w_volume_final) / (w_trend_final + w_momentum_final + w_structure_final + w_divergence_final)
w_trend_final *= adjustment_factor
w_momentum_final *= adjustment_factor
w_structure_final *= adjustment_factor
w_divergence_final *= adjustment_factor

ultimate_bull_confidence = (trend_score_bull * w_trend_final) + 
                          (momentum_score_bull * w_momentum_final) + 
                          (structure_score_bull * w_structure_final) + 
                          (volume_score_bull * w_volume_final) + 
                          (divergence_score_bull * w_divergence_final)

ultimate_bear_confidence = (trend_score_bear * w_trend_final) + 
                          (momentum_score_bear * w_momentum_final) + 
                          (structure_score_bear * w_structure_final) + 
                          (volume_score_bear * w_volume_final) + 
                          (divergence_score_bear * w_divergence_final)

// ETH-specific adjustments (EXACT MATCH)
if is_eth_symbol
    // ETH requires higher confluence due to volatility
    ultimate_bull_confidence *= 0.9  // Slightly more conservative
    ultimate_bear_confidence *= 0.9
    
    // Additional ETH momentum filter
    if rsi > 70 or stoch_k > 85
        ultimate_bull_confidence *= 0.7  // Reduce bullish confidence in overbought
    if rsi < 30 or stoch_k < 15
        ultimate_bear_confidence *= 0.7  // Reduce bearish confidence in oversold

// SOL-specific adjustments (EXACT MATCH)
if is_sol_symbol
    ultimate_bull_confidence *= 1.1  // SOL momentum boost
    ultimate_bear_confidence *= 1.1

confidence_bull = math.min(1.0, ultimate_bull_confidence)
confidence_bear = math.min(1.0, ultimate_bear_confidence)

// =====================
// === DYNAMIC CONFIDENCE ADJUSTMENT (EXACT MATCH)
// =====================

var float dynamic_min_confidence = min_confidence
var int performance_check_bars = 0

// Performance tracking variables (simulated for indicator)
var int total_signals = 0
var int winning_signals = 0
var float win_rate = 0.0

// Check performance every 100 bars (EXACT MATCH)
performance_check_bars += 1
if performance_check_bars >= 100
    performance_check_bars := 0
    
    // Simulate win rate calculation based on market conditions
    // In real strategy, this would be based on actual trade results
    market_volatility = atr / ta.sma(atr, 50)
    trend_strength = math.abs(ema_fast - ema_slow) / ema_slow
    
    // Simulate win rate based on market conditions
    if market_volatility < 0.8 and trend_strength > 0.02
        win_rate := 0.65  // Good trending market
    else if market_volatility > 1.5
        win_rate := 0.35  // High volatility market
    else
        win_rate := 0.50  // Neutral market
    
    // Adjust dynamic_min_confidence based on win rate (EXACT MATCH)
    if win_rate < 0.4
        dynamic_min_confidence := math.min(dynamic_min_confidence + 0.05, 0.85)
    else if win_rate > 0.6
        dynamic_min_confidence := math.max(dynamic_min_confidence - 0.02, min_confidence)

// =====================
// === SIGNAL GENERATION (EXACT MATCH)
// =====================

var int last_long_bar = na
var int last_short_bar = na

// Entry conditions (EXACT MATCH)
base_can_enter_long = allow_long and confidence_bull >= min_confidence and 
                 volume_confirmation and atr_filter and
                 (na(last_long_bar) or (bar_index - last_long_bar) > cooldown_bars) and
                 not (rsi > 85)  // Relaxed overbought filter

base_can_enter_short = allow_short and confidence_bear >= min_confidence and 
                  volume_confirmation and atr_filter and
                  (na(last_short_bar) or (bar_index - last_short_bar) > cooldown_bars) and
                  not (rsi < 15)  // Relaxed oversold filter

// Implement signal priority logic to prevent dual signals (EXACT MATCH)
can_enter_long = base_can_enter_long and (not base_can_enter_short or confidence_bull > confidence_bear)
can_enter_short = base_can_enter_short and (not base_can_enter_long or confidence_bear > confidence_bull)

// Update last signal bars
if can_enter_long
    last_long_bar := bar_index
if can_enter_short
    last_short_bar := bar_index

// =====================
// === SMART ALERT SYSTEM (EXACT MATCH)
// =====================

// Track last alert bar to prevent spam (increased cooldown)
var int last_alert_bar = na
var string last_alert_type = na

// Minimum bars between alerts (prevent TradingView "frequent triggers" pause)
// Ubah menjadi input agar bisa disesuaikan dari UI
alert_cooldown_bars = input.int(3, "Alert Cooldown Bars", minval=1, maxval=100, group="Execution")  // Dari 15 â†’ 3
// Basic alert eligibility (with proper cooldown)
alert_cooldown_ok = na(last_alert_bar) or (bar_index - last_alert_bar) >= alert_cooldown_bars

// Calculate which signal has higher confidence
bull_signal_strength = can_enter_long ? confidence_bull : 0.0
bear_signal_strength = can_enter_short ? confidence_bear : 0.0

// Gunakan threshold dinamis hanya jika toggle aktif; kalau tidak, fallback ke min_confidence
threshold_conf = use_dynamic_confidence ? dynamic_min_confidence : min_confidence

// Determine the dominant signal (only if above minimum threshold)
dominant_is_bull = bull_signal_strength > bear_signal_strength and bull_signal_strength >= threshold_conf
dominant_is_bear = bear_signal_strength > bull_signal_strength and bear_signal_strength >= threshold_conf

// Final alert conditions - ONLY ONE CAN BE TRUE (EXACT MATCH)
long_alert_condition = dominant_is_bull and alert_cooldown_ok and can_enter_long
short_alert_condition = dominant_is_bear and alert_cooldown_ok and can_enter_short

// Get actual confidence values for alerts
alert_confidence_bull = math.round(confidence_bull * 100) / 100  // Round to 2 decimals
alert_confidence_bear = math.round(confidence_bear * 100) / 100  // Round to 2 decimals

// Update alert tracking (EXACT MATCH)
if long_alert_condition
    last_alert_bar := bar_index
    last_alert_type := "LONG"
else if short_alert_condition
    last_alert_bar := bar_index
    last_alert_type := "SHORT"

// Debug plots untuk melihat threshold, confidence, dan kondisi masuk
plot(show_debug ? dynamic_min_confidence * 100 : na, "Dynamic Min Confidence (%)", color=color.yellow)
plot(show_debug ? (use_dynamic_confidence ? threshold_conf * 100 : min_confidence * 100) : na, "Alert Threshold (%)", color=color.new(color.yellow, 60))
plot(show_debug ? confidence_bull * 100 : na, "Bull Confidence (%)", color=color.green)
plot(show_debug ? confidence_bear * 100 : na, "Bear Confidence (%)", color=color.red)
plotshape(show_debug and can_enter_long, title="Can Enter Long", style=shape.circle, color=color.lime, location=location.belowbar, size=size.tiny)
plotshape(show_debug and can_enter_short, title="Can Enter Short", style=shape.circle, color=color.orange, location=location.abovebar, size=size.tiny)
plotshape(show_debug and dominant_is_bull, title="Dominant Bull", style=shape.triangleup, color=color.green, location=location.belowbar, size=size.tiny)
plotshape(show_debug and dominant_is_bear, title="Dominant Bear", style=shape.triangledown, color=color.red, location=location.abovebar, size=size.tiny)
plotshape(show_debug and long_alert_condition, title="Long Alert TRUE", style=shape.labelup, color=color.new(color.green, 0), location=location.belowbar, size=size.tiny, text="ALERT LONG")
plotshape(show_debug and short_alert_condition, title="Short Alert TRUE", style=shape.labeldown, color=color.new(color.red, 0), location=location.abovebar, size=size.tiny, text="ALERT SHORT")

// =====================
// === HIDDEN PLOTS FOR WEBHOOK DATA (EXACT MATCH)
// =====================

// Plot confidence values for alert placeholders (plot_0, plot_1, plot_2, plot_3)
plot(alert_confidence_bull, "Alert Bull Confidence", color=color.new(color.green, 100), display=display.none)  // plot_0
plot(bull_signal_strength, "Alert Bull Signal Strength", color=color.new(color.lime, 100), display=display.none)  // plot_1
plot(alert_confidence_bear, "Alert Bear Confidence", color=color.new(color.red, 100), display=display.none)  // plot_2
plot(bear_signal_strength, "Alert Bear Signal Strength", color=color.new(color.orange, 100), display=display.none)  // plot_3

// =====================
// === ALERT CONDITIONS (EXACT MATCH)
// =====================

// Simplified alert conditions - Bot handles TP/SL automatically
alertcondition(long_alert_condition, title="ðŸŽ¯ Sniper BUY Signal", 
               message='{"action": "BUY", "symbol": "{{ticker}}", "price": {{close}}, "token": "sniper-bybit-production-2024"}')

alertcondition(short_alert_condition, title="ðŸŽ¯ Sniper SELL Signal", 
               message='{"action": "SELL", "symbol": "{{ticker}}", "price": {{close}}, "token": "sniper-bybit-production-2024"}')

// =====================
// === VISUALIZATION
// =====================

// Plot EMAs
plot(show_ema ? ema_fast : na, "EMA Fast", color=color.blue, linewidth=2)
plot(show_ema ? ema_slow : na, "EMA Slow", color=color.red, linewidth=2)
plot(show_ema ? ema_htf : na, "EMA HTF", color=color.purple, linewidth=2, style=plot.style_circles)

// Plot VWAP
plot(vwap, "VWAP", color=color.new(color.orange, 30), linewidth=3, style=plot.style_line)

// Plot Fibonacci Levels
plot(show_sr_zones ? fib_618 : na, "Fib 61.8%", color=color.new(color.yellow, 50), linewidth=1, style=plot.style_stepline)
plot(show_sr_zones ? fib_382 : na, "Fib 38.2%", color=color.new(color.aqua, 50), linewidth=1, style=plot.style_stepline)
plot(show_sr_zones ? fib_236 : na, "Fib 23.6%", color=color.new(color.lime, 70), linewidth=1, style=plot.style_stepline)

// Enhanced S&R zones
if show_sr_zones and not na(nearest_support)
    support_top = nearest_support * (1 + sr_tolerance_pct)
    support_bottom = nearest_support * (1 - sr_tolerance_pct)
    support_color = (at_fib_618 or at_fib_382) ? color.new(color.green, 50) : color.new(color.green, 80)
    box.new(bar_index - 1, support_top, bar_index, support_bottom, border_color=color.new(color.green, 70), bgcolor=support_color)

if show_sr_zones and not na(nearest_resistance)
    resistance_top = nearest_resistance * (1 + sr_tolerance_pct)
    resistance_bottom = nearest_resistance * (1 - sr_tolerance_pct)
    resistance_color = (at_fib_618 or at_fib_382) ? color.new(color.red, 50) : color.new(color.red, 80)
    box.new(bar_index - 1, resistance_top, bar_index, resistance_bottom, border_color=color.new(color.red, 70), bgcolor=resistance_color)

// Plot confidence levels for debugging
plot(confidence_bull * 100, "Bull Confidence %", color=color.green, linewidth=2)
plot(confidence_bear * 100, "Bear Confidence %", color=color.red, linewidth=2)
plot(dynamic_min_confidence * 100, "Dynamic Min Confidence %", color=color.yellow, linewidth=1, style=plot.style_line)

// Plot signal strength comparison
plot(bull_signal_strength * 100, "Bull Signal Strength %", color=color.lime, linewidth=1, style=plot.style_stepline)
plot(bear_signal_strength * 100, "Bear Signal Strength %", color=color.orange, linewidth=1, style=plot.style_stepline)

// Plot final alert conditions (EXACT MATCH with strategy)
plotshape(long_alert_condition, title="ðŸŽ¯ LONG ALERT SENT", location=location.belowbar, color=color.lime, style=shape.triangleup, size=size.normal)
plotshape(short_alert_condition, title="ðŸŽ¯ SHORT ALERT SENT", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.normal)

// Plot entry conditions for comparison (smaller shapes)
plotshape(can_enter_long and not long_alert_condition, title="Long Ready (No Alert)", location=location.belowbar, color=color.green, style=shape.circle, size=size.tiny)
plotshape(can_enter_short and not short_alert_condition, title="Short Ready (No Alert)", location=location.abovebar, color=color.orange, style=shape.circle, size=size.tiny)

// Background color for volume confirmation
bgcolor(volume_confirmation ? color.new(color.green, 95) : color.new(color.red, 95), title="Volume Filter Status")

// =====================
// === DEBUG INFO (EXACT MATCH)
// =====================

if show_debug
    var table debug_table = table.new(position.top_right, 2, 15, bgcolor=color.white, border_width=1)
    
    if barstate.islast
        // Clear table
        table.clear(debug_table, 0, 0)
        
        // Header
        table.cell(debug_table, 0, 0, "SNIPER DEBUG", text_color=color.white, bgcolor=color.blue, text_size=size.small)
        table.cell(debug_table, 1, 0, "VALUES", text_color=color.white, bgcolor=color.blue, text_size=size.small)
        
        // Confidence Scores
        table.cell(debug_table, 0, 1, "Bull Confidence", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 1, str.tostring(confidence_bull, "#.###"), text_color=confidence_bull >= min_confidence ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 2, "Bear Confidence", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 2, str.tostring(confidence_bear, "#.###"), text_color=confidence_bear >= min_confidence ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 3, "Dynamic Min", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 3, str.tostring(dynamic_min_confidence, "#.##"), text_color=color.blue, text_size=size.tiny)
        
        // Filter Status
        table.cell(debug_table, 0, 4, "Volume Filter", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 4, volume_confirmation ? "âœ“ PASS" : "âœ— FAIL", text_color=volume_confirmation ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 5, "ATR Filter", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 5, atr_filter ? "âœ“ PASS" : "âœ— FAIL", text_color=atr_filter ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 6, "Volume Ratio", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 6, str.tostring(volume_ratio, "#.##"), text_color=volume_ratio > 1.5 ? color.green : color.orange, text_size=size.tiny)
        
        // Entry Readiness
        table.cell(debug_table, 0, 7, "Can Enter Long", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 7, can_enter_long ? "âœ“ YES" : "âœ— NO", text_color=can_enter_long ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 8, "Can Enter Short", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 8, can_enter_short ? "âœ“ YES" : "âœ— NO", text_color=can_enter_short ? color.green : color.red, text_size=size.tiny)
        
        // Alert Status
        table.cell(debug_table, 0, 9, "Long Alert", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 9, long_alert_condition ? "ðŸŽ¯ SENT" : "â¸ WAIT", text_color=long_alert_condition ? color.lime : color.gray, text_size=size.tiny)
        
        table.cell(debug_table, 0, 10, "Short Alert", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 10, short_alert_condition ? "ðŸŽ¯ SENT" : "â¸ WAIT", text_color=short_alert_condition ? color.red : color.gray, text_size=size.tiny)
        
        table.cell(debug_table, 0, 11, "Alert Cooldown", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 11, alert_cooldown_ok ? "âœ“ OK" : "â³ WAIT", text_color=alert_cooldown_ok ? color.green : color.orange, text_size=size.tiny)
        
        table.cell(debug_table, 0, 12, "RSI Value", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 12, str.tostring(rsi, "#.#"), text_color=rsi > 70 ? color.red : rsi < 30 ? color.green : color.gray, text_size=size.tiny)
        
        table.cell(debug_table, 0, 13, "Win Rate", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 13, str.tostring(win_rate * 100, "#.#") + "%", text_color=win_rate > 0.5 ? color.green : color.red, text_size=size.tiny)
        
        table.cell(debug_table, 0, 14, "Current Bar", text_color=color.black, text_size=size.tiny)
        table.cell(debug_table, 1, 14, str.tostring(bar_index), text_color=color.gray, text_size=size.tiny)

// =====================
// === END OF SNIPER INDICATOR
// =====================